
\documentclass[a4paper,12pt]{article}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}

\title{\textbf{Trabalho Prático de Compiladores I \\ Etapa 2: Analisador Léxico \\Anexo I: Código-fonte}}
\author{
   Felipe Buzatti e Letícia Lana Cherchiglia \\
   \{buzatti,letslc\}@dcc.ufmg.br \\ \\
   \textit{Departamento de Ciência da Computação}\\
   \textit{Universidade Federal de Minas Gerais}\\
}
\date{09 de Abril de 2011}

\begin{document}
\maketitle

\section{Lista dos Arquivos}
\begin{enumerate}
 \item lexikon.h
 \item lexikon.c
\end{enumerate}

\section{lexikon.h}

\begin{footnotesize}
\begin{verbatim}

#include <stdio.h>

#define TAM_BUFFER_ENTR 300
#define TAM_BUFFER_ESP 3
#define TAM_TIPO_SIMB 50

typedef short flag;

/*
	Faz a análise léxica de uma linha do arquivo. Retorna 1 quando encontra
uma quebra de linha, e 0 quando encontra final do arquivo.
*/
int analise_lex(FILE * arquivo);
void exporta_buffer(char buffer[TAM_BUFFER_ENTR], int * ind_buffer, flag tipo);
void exporta_simbolo(char valor, char tipo_simb[TAM_TIPO_SIMB]);
void exporta_buffer_esp(char valor[TAM_BUFFER_ESP], char tipo_simb[TAM_TIPO_SIMB]);

//========HASH palavras reservadas=======//

typedef struct{
	char valor[TAM_BUFFER_ENTR];
	char tipo_simb[TAM_TIPO_SIMB];
} tipo_entr_hash;

#define TAM_HASH 50

//retorna o hash, já contendo as palavras reservadas
tipo_entr_hash ** inicializa_hash();
void insere_hash(tipo_entr_hash ** tab_hash, char * valor, char * tipo_simb);
int calcula_hash(char * termo);
//retorna 1 caso a palavra passada seja reservada, 0 caso contrário
int consulta_hash(tipo_entr_hash ** tab_hash, char palavra[TAM_BUFFER_ENTR], 
                                             char tipo_simb[TAM_TIPO_SIMB]);
void libera_hash(tipo_entr_hash ** tab_hash);


\end{verbatim}
\end{footnotesize}

\section{lexikon.c}

\begin{footnotesize}
\begin{verbatim}
 #include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "lexikon.h"

//macros para trabalhar com a flag tipo. Testam se o tipo se refere a uma 
//palavra, um número, e de que tipo.
#define EH_NUMERO ((tipo & 1) == 1)
#define EH_PALAVRA ((tipo & 2) == 2)
#define EH_INTEIRO ((tipo & 4) == 4)
#define EH_REAL ((tipo & 8) == 8)

//declara tabela hash
tipo_entr_hash ** tabela;

int main (int argc, char *argv[]){
	//inicializa tab_hash, que é uma variável global
	tabela = inicializa_hash();
	
	if (argc != 2){
		fprintf(stderr, "\nSintaxe correta: arquivo_entrada\n");
		exit(1);
	}
	
	FILE * arq_entrada;
	arq_entrada = fopen(argv[1], "r");
	
	printf("Valor&Tipo\\\\\n");
	do{ //lê todas as linhas
	} while (analise_lex(arq_entrada));
	
	libera_hash(tabela);
	return 0;
}

int analise_lex(FILE * arquivo){
	char c = fgetc(arquivo);
	char buffer[TAM_BUFFER_ENTR];
	char buffer_esp[3];
	
	/*
		flag que guarda informações sobre o buffer a ser exportado. 
	Utiliza-se os bits da flag para guardar as informações. Dessa forma o
	bit zero define se o buffer contém um número, o bit um, uma palavra, o 
	dois, se é um número inteiro, e o bit quatro se é um númeroreal.
		Isso significa que um número real teria essa flag com o valor
	9. que é 00001001; e uma palavra teria tipo==2, ou seja 00000010.
	*/
	flag tipo=0;
	
	int ind_buffer=0; //marca ponto em que o caractere deve ser inserido no 
									//buffer
	
	while(!feof(arquivo)){
		switch(c){
			case '+':
				exporta_buffer(buffer, &ind_buffer, tipo);
				exporta_simbolo(c, "addop");
				break;
			case '*':
				exporta_buffer(buffer, &ind_buffer, tipo);
				exporta_simbolo(c, "mulop");
				break;
			case '\'':
				exporta_buffer(buffer, &ind_buffer, tipo);
				c = fgetc(arquivo);
				if (isalpha(c))
					exporta_simbolo(c, "constant_char");
				else{
					fprintf(stderr, "\nErro: caractere %c não 
                                                         reconhecido\n", c);
					exit(1);
				}
				c = fgetc(arquivo);
				if (c != '\''){
					fprintf(stderr, "\nErro: esperado '\n", c);
					exit(1);
				}
				break;
			case '(':
			case ')':
				exporta_buffer(buffer, &ind_buffer, tipo);
				exporta_simbolo(c, "parenteses");
				break;
			case '[':
			case ']':
				exporta_buffer(buffer, &ind_buffer, tipo);
				exporta_simbolo(c, "colchetes");
				break;
			case ',':
				exporta_buffer(buffer, &ind_buffer, tipo);
				exporta_simbolo(c, "vírgula");
				break;
			case ';':
				exporta_buffer(buffer, &ind_buffer, tipo);
				exporta_simbolo(c, "ponto-vírgula");
				break;
			case '=':
				exporta_buffer(buffer, &ind_buffer, tipo);
				exporta_simbolo(c, "relop");
				break;
			case '<':
			case '!':
				exporta_buffer(buffer, &ind_buffer, tipo);
				buffer_esp[0] = c;
				if ((c = fgetc(arquivo)) == '='){
					buffer_esp[1] = c;
					buffer_esp[2] = '\0';
					exporta_buffer_esp(buffer_esp, "relop");
				} else{
					fseek(arquivo, -1, SEEK_CUR); //retorna
								//caractere lido
					exporta_simbolo(buffer_esp[0], "relop");
				}
				break;
			case ':':
				exporta_buffer(buffer, &ind_buffer, tipo);
				buffer_esp[0] = c;
				if ((c = fgetc(arquivo)) == '='){
					buffer_esp[1] = c;
					buffer_esp[2] = '\0';
					exporta_buffer_esp(buffer_esp, "atrib");
				} else{
					fseek(arquivo, -1, SEEK_CUR); //retorna
								//caractere lido
					exporta_simbolo(buffer_esp[0], "dois pontos");
				}
				break;
			case '\n':
				exporta_buffer(buffer,&ind_buffer, tipo);
				return 1;
			case ' ': //espaços representam final de um termo, ou são ignorados
			case '\t':
				exporta_buffer(buffer,&ind_buffer, tipo);
				
				//reinicia o buffer
				ind_buffer=0;
				break;
			case 'E':
			case '.':
				buffer[ind_buffer++] = c;
				if (EH_NUMERO){
					tipo = 9; //trata-se de um número real
				}
				break;
			case '-':
				if (buffer[ind_buffer-1] == 'E'){
					buffer[ind_buffer++] = c;
					break;
				}
				
			default: //caso em que pode se tratar de uma letra ou número
				if (ind_buffer == 0) {
					if (isdigit(c)){
						tipo = 5; //define que se trata de um número, 
							            inteiro, até que se prove o contrário
					} else if (isalpha(c) || c == '_'){
						tipo=1; //define que se trata de uma palavra
					}
				}
				if (isalnum(c) || (!EH_NUMERO  && c == '_')){
					buffer[ind_buffer++] = c; //lê para buffer
				} else{
					fprintf(stderr, "\nErro: caractere %c não reconhecido\n", c);
					exit(1);
				}
				break;
				
		}
		c = fgetc(arquivo);
		
		
		
	}
	
	return 0;
}

void exporta_buffer(char buffer[TAM_BUFFER_ENTR], int * ind_buffer, flag tipo){
	char tipo_simb[TAM_TIPO_SIMB];
	
	if ((*ind_buffer) == 0){
		return; //significa que o buffer ainda não tem nenhum caractere
	}
	
	buffer[(*ind_buffer)++] = '\0';
	if (EH_INTEIRO){
		printf("%d&Número inteiro\\\\\n", atoi(buffer));
	} else if (EH_REAL){
		printf("%g&Número real\\\\\n", atof(buffer));
	} else if (consulta_hash(tabela, buffer, tipo_simb)){ //se é palavra reservada
		printf("%s&%s\\\\\n", buffer, tipo_simb);
	} else{
		printf("%s&Identificador\\\\\n", buffer);
	}
	
	(*ind_buffer) = 0;
}

void exporta_simbolo(char valor, char tipo_simb[TAM_TIPO_SIMB]){
	printf("%c&%s\\\\\n", valor, tipo_simb);
}

void exporta_buffer_esp(char valor[TAM_BUFFER_ESP], char tipo_simb[TAM_TIPO_SIMB]){
	printf("%s&%s\\\\\n", valor, tipo_simb);
}

//========HASH palavras reservadas=======//

tipo_entr_hash ** inicializa_hash(){
	tipo_entr_hash ** tab_hash;
	tab_hash = malloc(sizeof(tipo_entr_hash *)*TAM_HASH);
	
	int i;
	for (i = 0; i < TAM_HASH; i += 1){
		tab_hash[i] = NULL; //zera as posições da tabela.
	}
	
	//Insere as palavras reservadas(O número de entradas aqui não pode ultrapassar TAM_HASH):
	insere_hash(tab_hash, "program", "program");
	insere_hash(tab_hash, "declare", "block-stmt");
	insere_hash(tab_hash, "do", "block-stmt");
	insere_hash(tab_hash, "integer", "simple-type");
	insere_hash(tab_hash, "real", "simple-type");
	insere_hash(tab_hash, "boolean", "simple-type");
	insere_hash(tab_hash, "char", "simple-type");
	insere_hash(tab_hash, "label", "simple-type");
	insere_hash(tab_hash, "array", "array-type");
	insere_hash(tab_hash, "of", "array-type");
	insere_hash(tab_hash, "procedure", "procedure");
	insere_hash(tab_hash, "if", "if-stmt");
	insere_hash(tab_hash, "then", "if-stmt");
	insere_hash(tab_hash, "else", "if-stmt");
	insere_hash(tab_hash, "end", "end");
	insere_hash(tab_hash, "while", "while-stmt");
	insere_hash(tab_hash, "do", "while-stmt");
	insere_hash(tab_hash, "read", "read-stmt");
	insere_hash(tab_hash, "write", "write-stmt");
	insere_hash(tab_hash, "goto", "goto");
	insere_hash(tab_hash, "return", "return");
	insere_hash(tab_hash, "write", "write");
	insere_hash(tab_hash, "not", "not");
	insere_hash(tab_hash, "or", "addop");
	insere_hash(tab_hash, "and", "mulop");
	insere_hash(tab_hash, "false", "boolean-constant");
	insere_hash(tab_hash, "true", "boolean-constant");
	
	//retorna o hash criado
	return tab_hash;
}

void insere_hash(tipo_entr_hash ** tab_hash, char * valor, char * tipo_simb){
	//procura por uma posição para inserir
	int posicao_hash = calcula_hash(valor);;
	while (tab_hash[posicao_hash] != NULL){ //procura uma posição livre da tabela
		posicao_hash+=1;
	}
	
	tipo_entr_hash * nova = malloc(sizeof(tipo_entr_hash));
	strcpy(nova->valor, valor);
	strcpy(nova->tipo_simb, tipo_simb);
	
	tab_hash[posicao_hash] = nova;
}

int calcula_hash(char * termo){
	int resultado=0;
	
	int i;
	for (i = 0; termo[i] != '\0'; i += 1){
		resultado = (resultado+(int)termo[i])%TAM_HASH;
	}
	
	return resultado;
}

int consulta_hash(tipo_entr_hash ** tab_hash, char palavra[TAM_BUFFER_ENTR], 
                  char tipo_simb[TAM_TIPO_SIMB]){
	int valor_hash = calcula_hash(palavra);
	
	while (tab_hash[valor_hash] != NULL && 
               strcmp(tab_hash[valor_hash]->valor, palavra) != 0){
		valor_hash+=1;
	}
	
	if (tab_hash[valor_hash] == NULL){
			return 0;
	} else{
		strcpy(tipo_simb, tab_hash[valor_hash]->tipo_simb);
		return 1;
	}
}

void libera_hash(tipo_entr_hash ** tab_hash){
	int i;
	for (i = 0; i < TAM_HASH; i += 1){
		if (tab_hash[i] != NULL){
			free(tab_hash[i]);
		}
	}
	
	free(tab_hash);
}
\end{verbatim}
\end{footnotesize}


\end{document}

